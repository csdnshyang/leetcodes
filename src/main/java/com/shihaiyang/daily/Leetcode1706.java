package com.shihaiyang.daily;

// 1706. 球会落何处.[模拟2ms].

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

/**
 * 用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。
 * 箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。
 * 将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。
 * 将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。
 * 在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 "V" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。
 * 返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。
 * 示例 1：
 * 输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
 * 输出：[1,-1,-1,-1,-1]
 * 解释：示例如图：
 * b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。
 * b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。
 * b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。
 * b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。
 * b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。
 * 示例 2：
 * 输入：grid = [[-1]]
 * 输出：[-1]
 * 解释：球被卡在箱子左侧边上。
 * 示例 3：
 * 输入：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
 * 输出：[0,1,2,3,4,-1]
 * <p>
 * 提示：
 * 1 <= m, n <= 100
 * grid[i][j] 为 1 或 -1
 *
 * [[-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,1,1,-1,-1,-1,-1]]
 */
public class Leetcode1706 {
    Solution1706 solution1706 = new Solution1706();

    @Test
    public void case1() {
        int[][] ball = new int[][]{
                {1,1,1,-1,-1},
                {1,1,1,-1,-1},
                {-1,-1,-1,1,1},
                {1,1,1,1,-1},
                {-1,-1,-1,-1,-1}
        };
        int[] ints = solution1706.findBall(ball);
        Assertions.assertArrayEquals(ints, new int[]{1,-1,-1,-1,-1});
    }
    @Test
    public void case2() {
        int[][] ball = new int[][]{
                {1,1,1,1,1,1},
                {-1,-1,-1,-1,-1,-1},
                {1,1,1,1,1,1},
                {-1,-1,-1,-1,-1,-1},
        };
        int[] ints = solution1706.findBall(ball);
        Assertions.assertArrayEquals(ints, new int[]{0,1,2,3,4,-1});
    }
    @Test
    public void case3() {
        int[][] ball = new int[][]{
                {-1},
        };
        int[] ints = solution1706.findBall(ball);
        Assertions.assertArrayEquals(ints, new int[]{-1});
    }
    @Test
    public void case4() {
        int[][] ball = new int[][]{
                {-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,1,1,-1,-1,-1,-1},
        };
        int[] ints = solution1706.findBall(ball);
        Assertions.assertArrayEquals(ints, new int[]{-1,-1,-1,2,3,4,5,6,-1,-1,9,10,11,14,-1,-1,15,16,19,20,-1,-1,21,24,-1,-1,25,-1,-1,28,29,30,31,32,33,34,35,-1,-1,-1,-1,40,41,42,43,44,45,-1,-1,48,-1,-1,-1,-1,53,56,-1,-1,-1,-1,59,60,61,64,65,66,67,68,-1,-1,71,72,-1,-1,75,76,-1,-1,77,78,-1,-1,-1,-1,83,86,-1,-1,87,-1,-1,-1,-1,94,95,-1,-1,96,97,98});
    }

}

/*
模拟即可
这个球要按列先遍历，每一列从第一行遍历到最后一行。
k=球初始列数
当grid[i][j]==1说明向右走 && j+1<grid.len说明没有到边界 && grid[i][j+1]==1说明没有被夹
        那么球就往右 k+=1;
当grid[i][j]==-1说明向左走 && j-1>=0说明没有到边界 && grid[i][j-1]==-1说明没有被夹
        那么球就往左 k-=1;
两个都不满足，说明要么被夹，要么到边界
        那么直接返回-1;break;
 */
class Solution1706 {
    public int[] findBall(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[] ret = new int[n];
        for (int j = 0; j < n; j++) {
            // 列
            int k = j;
            for (int i = 0; i < m; i++) {
                // 最后一行
                if (grid[i][k] == 1 && k + 1 < n && grid[i][k + 1] == 1) {
                    k = k + 1;
                } else if (grid[i][k] == -1 && k - 1 >= 0 && grid[i][k - 1] == -1) {
                    k = k - 1;
                } else {
                    k = -1;
                    break;
                }
            }
            ret[j] = k;
        }
        return ret;
    }
}