package com.shihaiyang.daily;

// 1994. 好子集的数目[状态压缩动态规划 10ms].

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.stream.IntStream;

/**
 * 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。
 *
 * 比方说，如果 nums = [1, 2, 3, 4] ：
 * [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。
 * [1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。
 * 请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。
 *
 * nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。
 *
 * 示例 1：
 *
 * 输入：nums = [1,2,3,4]
 * 输出：6
 * 解释：好子集为：
 * - [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
 * - [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
 * - [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
 * - [2]：乘积为 2 ，可以表示为质数 2 的乘积。
 * - [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
 * - [3]：乘积为 3 ，可以表示为质数 3 的乘积。
 * 示例 2：
 *
 * 输入：nums = [4,2,3,15]
 * 输出：5
 * 解释：好子集为：
 * - [2]：乘积为 2 ，可以表示为质数 2 的乘积。
 * - [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
 * - [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
 * - [3]：乘积为 3 ，可以表示为质数 3 的乘积。
 * - [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。
 */
public class Leetcode1994 {
    @Test
    public void case1() {
        Solution1994 solution1994 = new Solution1994();
        int subsets = solution1994.numberOfGoodSubsets(new int[]{1, 2, 3, 4});
        Assertions.assertEquals(subsets, 6);
    }
    @Test
    public void case2() {
        Solution1994 solution1994 = new Solution1994();
        int subsets = solution1994.numberOfGoodSubsets(new int[]{1,2,3,4,5,1,5,5,5,5,3,7,7,7,7,8,8,8,8,9,9,2,2,11,11,11,11,17});
        Assertions.assertEquals(subsets, 14396);
    }
}



/*
 状态压缩动态规划
 这个花了好几天在思考，正巧今天早上看到了一个字节的状态压缩的面试题。
 首先理解这个题花了很久，其实到最后一天也在思考这个题的结果到底是什么意思
 题目是要求 好子集的个数。好子集的意思是数组的某个子数组中的元素都是质数，并且互不相同。
 题目中给的提示是nums[i]<30，所以好子集中的元素有几种情况
 1. 质数只有10个  [2,3,5,7,11,13,17,19,23,29]，所以某个数组的好子集一定是从这10个数里选择的某几个元素组成的。
      像  [2,3,5]   [7,11] 这都算好数组，或者好子集。
 2. 而4,8,9,12,16,18,24,25,27,28都是本身包含重复因子的，肯定不能包含在好子集里，可以直接排除(可以简化成%4,%9,%25 == 0)
 3. 像6,10,15这一类，也可以包含在好子集里，但是就会占用两个质数，比如15，如果作为好子集的元素，那么其他元素就不能包含3，5两个了。

 基于上面3中情况。可以抽象成一个状态state，这个state的含义就是一个用一个10位的二进制位来标识这个好子集里有哪些元素，2是0001, 3是0010  5是0100等
      比如[2,3] 就对应的是 0011
      比如[3,5,11] 对应就是  0001 0110
      比如[7,15]  对应就是3，5，7  就是 1110
 上面这个例子可以看出，可能有不同的因子，但是对应的状态是一致的[3,5,7]与[7,15]都是对应的 1110，
          这个就是动态规划的转移方程的一部分，计算一个state的数量的时候，需要本身的数量加上新的数量。

 上面的描述中就把好子集的含义，组成好子集的情况，以及用state标识一个好子集的方法说完了。
 下面就是动态规划的部分。或者说怎么计算某个state对应的好子集数量

 state怎么计算数量呢？首先我们要看题意中数量的定义是什么样。
 [1,2,3,4] 中[2][3][2,3]都是好子集，并且每个元素重复之后都是算数的，即[1,2,2,3,4]中[2][2][3][2,3][2,3]都是计数的，所以需要先统计下数组中每个质数的个数count[nums]
 另外1是比较特殊，最后计算，相当于把上面除了1的好子集*2，并且有多少个1的元素，就是多少个2倍

因为30内有10个质数，每个质数作为一个二进制位，选择或者不选择，state的长度最大是2的9次方，即1024。
定义一个dp[1024]来标记每个state的好子集数量。
 计算一个元素的好子集数目时，就通过跟1024中所有的state状态计算，计算出加入该元素时，好子集的个数变化。
    计算逻辑：
        如果state中包含该元素，就跳过,这块计算用与运算>0
                比如[14,2] 对于元素2(0001)，当他跟14(0101)去计算时，(0001&0101>0)就会跳过，因为14中已经有了2这个元素的位数
        如果state不包含钙元素，就把合并该元素的好子集数据，这块用或运算。
                比如[2,3,5]  元素5(mask=0100),跟2(0001)组成好子集时，对应好子集[2,5]的state就是0101.就应该更新dp[4]的数量
                比如[2,3,7,14]  好子集[14](mask=1001)对应的是dp[9]的数量。而好子集[2,7](mask=1001)同样对应的dp[9]的数量，会对他的数量做更新。
                dp[最终state]=dp[最终state]+新的计数
                最终state=mask|state   , 新的计数就等于count[nums] * dp[state]

质数数组定义： [2,3,5,7,11,13,17,19,23,29]
count[31] 每个元素的个数统计
dp[1024] 不同质数对应的state的的好子集个数
dp[0]=1 // 初始值
接下来完整看一个数组好子集的计算过程 [1,2,2,2,5,5,10]
1. 先统计每个元素个数   count[1]=1,count[2]=3,count[5]=2,count[10]=1
2. 计算2..30每个数字对应的质数mask，并跟新state的好子集数目    计算每个数。
   元素2：mask=0001
       遍历比较1024个状态
       state=0: 00&01==0  更新dp[1|0]的数量  dp[1|0]=dp[1|0]+count[2]*dp[0]=0+3*1=3;=>dp[1]=3// 这里可以看出dp[0]这个初始值的含义，就是为了更新只有一个质数元素的好子集的数量。[2]的数量就是count[2]
       state=1: 01&01>0 跳过
       其他state都是0,例如3(mask=0010) 10&01==0,dp[1|2]=dp[1|2]+count[2]*dp[2],即dp[3]=dp[3]+count[2]*dp[2]=0+3*0=0.//这里的dp[1]是指元素2的mask，count[2]是指元素2的出现次数。
   元素5：mask=0100
        遍历比较1024个状态
        state=0: 0100&0000==0 更新dp[0100|0]的数量 dp[4], dp[4|0]=dp[4|0]+count[5]*dp[0]=0+2*1=2; =>dp[4]=2;
        state=1: 0100&0001==0 更新dp[0100|0001]的数量 dp[5], dp[4|1]=dp[4|1]+count[5]*dp[1]=0+2*3=6;=>dp[5]=6;
                                   这块比较重要最终的好子集数据更新就是这个逻辑,这个就是在好子集[2]中加入元素5组成好子集[2,5]的个数变化。分成两部分
                                        第一部分：dp[0101]对应的原来的数目，就是[2,5]和[10]的变化，后面会遇到。计算10的时候，要都是更新dp[5],要再原来基础上追加新的数量
                                        第二部分：[2,5]好子集的数量，就是count[5]*dp[1]  count[5]是元素5出现的次数，dp[1]是好子集[2]的数量，相乘就是好子集[2,5]的数量,追加进dp[5]
        中间几个state略过。都是0
        state=5: 0100&0101>0  跳过，这个就是元素5和元素10，他们有共同的5作为因子，所以不能同时出现在一个好子集中。
        后面的state也都是0。跳过
    元素10: mask=0101
        遍历1024个状态
        state=0: 0101&0==0, 更新dp[0101|0]的数量dp[5],dp[0101|0]=dp[0101|0]+count[10]*dp[0]=dp[5]+count[10]*dp[0]=6+1*1=7;
                // 这个跟上面的dp[5]对应，遇到了相同的state，进行了一次追加。
        ...后面状态忽略了都是0
3. 统计好子集数目
结束遍历就把所有元素对应的state的好子集的数量都计算追加了一遍。除了1元素。
1024个state，就对应了10个质数的不同组合组成的好子集的数量。
比如 state=13(1101)就是质数[2,5,7]组成的好子集数量，可能是[2,5,7],也可能是[7,10],[5,14]，都是有2,5,7三个质数组成的，也都追加更新到了dp[1101]=dp[13]
比如 state=21(0001 1010)就是质数[3,7,11]组成的好子集数量，可能是[3,7,11],也可能是[7,33],[3,77]，都是有3,7,11三个质数组成的，也都追加更新到了dp[0001 1010]=dp[21]
遍历1024个state中所有的好子集数目之和就是所有元素能组成的好子集数目ans
再考虑1元素
    元素1：元素1比较特殊，因为前面所有元素组成的好子集，都能跟1组成一个新的好子集。就是加入1，就把原来好子集的数量 ans=ans*2.

完成。

*/

class Solution1994 {
    private final int mod=1000000007;
    int[] prime = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    public int numberOfGoodSubsets(int[] nums) {
        // 记录元素出现个数
        int[] count = new int[31];
        for (int num : nums) {
            count[num]++;
        }
        // 记录选择不同质数的状态state
        long[] dp = new long[1024];
        // 统计单个元素组成的好子集
        dp[0] = 1;
        // 计算所有可能的元素集合的mask，更新state好子集个数
        // 需要从2开始计算。
        for (int i = 2; i <= 30; i++) {
            final int num = i;
            if (count[num] == 0 || num % 4 == 0 || num % 9 == 0 || num % 25 == 0) {
                continue;
            }
            // 元素转化为二进制位  2=>0001  5=> 0100  10=> 0101
            int mask = IntStream.range(0, prime.length).filter(j -> (num % prime[j]) == 0).map(j -> 1 << j).reduce(0, (a, b) -> a | b);
            // 计算追加 与其他state(0..1024) 组成的好子集个数
            for (int state = 0; state < dp.length; state++) {
                if ((mask & state) == 0){
                    dp[mask | state] = (dp[mask | state] + count[num] * dp[state]) % mod;
                }
            }
        }
        // 统计1024个state的好子集之和 除了0
        long ans = 0;
        for (int i = 1; i < 1024; i++) {
            ans = (ans + dp[i]) % mod;
        }
        // 计算特殊元素1
        for (int i = 0; i < count[1]; i++) {
            ans = (ans * 2) % mod;
        }
        return (int) ans;
    }
}