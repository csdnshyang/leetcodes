package com.shihaiyang.leetcodes;

// 0483. 最小好进制.[最小满k叉树,数学公式 2ms].
public class Leetcode0483 {
    public static void main(String[] args) {
        Solution0483 solution0483 = new Solution0483();
        String goodBase = solution0483.smallestGoodBase("15");
        System.out.println(goodBase);
    }
}

/**
 * 对于给定的整数 n, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个好进制。
 * 以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。
 * 示例 1：
 * 输入："13"
 * 输出："3"
 * 解释：13 的 3 进制是 111。
 * 示例 2：
 * 输入："4681"
 * 输出："8"
 * 解释：4681 的 8 进制是 11111。
 * 输入："1000000000000000000"
 * 输出："999999999999999999"
 * 解释：1000000000000000000 的 999999999999999999 进制是 11。
 */


// 总和为n, 进制为k, 结合好进制(全为1)的定义, 即:
// 公式1: n = k^0 + k^1 + k^2 + ... + k^(m-1) + k^m
// 这里要求最小好进制，即要求k值尽可能小，也即m值(转换后的'bit'位数)尽可能大    // 所以k=2进制的时候，m位数是最大的。
// 依照等比数列的前n项和公式，公式1可化为:
// n = (1 - k^(m+1)) / (1 - k)
// 又依照题意，k >= 2，所以1-k不为0，上式可以转化为
// => (1-k)*n = 1 - k^(m+1)
// => k^(m+1) = kn - n + 1 < kn
// => k^(m+1) < kn
// =>     k^m < n
// =>       m < logk(n)
// 这里我们就求出了m的上界m_max = logk(n): 以k为底n的对数
// 对数函数随底数k增大而减小，随真数n增大而增大
// 这时候我们还不确定定k的取值，但依照题意，k>=2，n是给定的值，所以可以取k=2时得到本题m值的最大上界
// m_max = log2(n)

// 这时我们就把答案限制在一个很小的范围内了[2, m_max]
// 又因为我们最终所求k值要尽可能小，即要求m的值要尽可能大，所以我们待会儿可以从大到小遍历m的值，找到第一个符合要求的k值即返回

// 下面考虑如何寻找符合要求的k值(因为我们遍历可能的m取值，所以下面这些步骤可以把m当成已知量)
// 公式1: n = k^0 + k^1 + k^2 + ... + k^(m-1) + k^m
//    => n > k^m
//    => k < n.sqrt(m)  (对n开m方根)
// 公式2(二项式定理)(展开后的公式省略了):
//        (k+1)^m = ... > k^0 + k^1 + ... + k^(m-1) + k^m = n
//    =>  (k+1)^m > n
//    =>      k+1 > n.sqrt(m) (对n开m方根)
// 综上:  k < n.sqrt(m) < k+1
// 这里就限制住在当前n与m的取值情况下，k值应该为int(n.sqrt(m))

/**
 * 其实是一个满K叉树的样子，n就是满足k叉树的节点和。
 * 位数其实就是k叉树的深度h=logk(n)
 * 相同节点个数，当k最小，k=2，即二叉树的时候，深度最深。本题就是求得[完全最小k叉树] 就理解为满足完全树的最小k叉树吧...
 * 于是乎，我们想如果能满足完全二叉树那么一定是深度最深的。深度有多深呢？log2(n).那这个就是最深的深度了max_h=log2(n)
 * 最小深度就是除了一个根节点，其他节点都是叶子节点。min_h=2
 * 从最大的深度开始找。
 * k怎么计算？通过两个公式夹逼。
 * n = k^0 + k^1 + k^2 + ... + k^(m-1) + k^m  // k叉树总节点数  k < n.sqrt(m)
 * (k+1)^m = ... > k^0 + k^1 + ... + k^(m-1) + k^m = n  // 二次项展开式 二次项分别为k和1.所以1的n次方都是1。  k+1 > n.sqrt(m)
 * 得  k < n.sqrt(m) < k+1
 * k=n开m次方  就是n的1/m次方
 * 然后从2位开始计算，如果sum=n就成功。
 *
 * sum = sum * k + 1; // 就是左移一位+1
 */

/**
 *数学基础..
 *  等比数列n项和
 *  二次项展开式
 *数据结构..
 *  满k叉树最大高度
 */
class Solution0483 {
    /* 数学方法 */
    public String smallestGoodBase(String n) {
        long num = Long.parseLong(n);
        long maxh = (long)(Math.log(num) / Math.log(2)+1);
        // 从大bit位开始
        for (long h = maxh; h >= 2; h--) {
            long k = (long) Math.pow(num, 1.0 / (h-1));
            long sum = 0;
            for (int i = 0; i < h; i++) {
                // 左移一位+1   就是原值*k+1
                sum = sum * k + 1;
                if (sum == num) {
                    return String.valueOf(k);
                }
            }
        }
        return Long.toString(num - 1);
    }
}
